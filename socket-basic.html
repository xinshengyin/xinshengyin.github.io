<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>新声音</title>
  
  <link href="/assets/css/application.css" rel="stylesheet" type="text/css" media="all">
  <link href="/assets/css/syntax.css" rel="stylesheet" type="text/css" media="all">
  <link href="/assets/css/style.css" rel="stylesheet" type="text/css" media="all">
  <script src="/assets/js/jquery.js"></script>
  <script src="/assets/js/semantic.js"></script>
</head>

<body class="">

  <div class="ui top attached segment">
  <div class="ui menu secondary">

  

  
  <a href="/" class="item">首页</a>
  

  

  
  <a href="/category" class="item">分类</a>
  

  

  
  <a href="/about" class="item">关于我</a>
  

  
</div>
</div>

<main>
  <div class="ui invisible side">
  <div class="sidebar">
    <div class="ui inverted vertical fluid icon menu">
	<div class="header center link item" id="close_side">
		<i class="content icon"></i>
	</div>
	
	<div class="item ui dropdown">
		<a class="title">
			<i class="alarm outline icon"></i>
			<span>ruby</span>
		</a>
		<div class="menu content">
			
			<a href="/ruby/programer-think-with-product" class="item">工程师的产品观</a>
			
			<a href="/ruby/file-dir-pathname" class="item">理理File/Dir/Pathname（一）</a>
			
			<a href="/ruby/trace-point" class="item">TracePoint介绍</a>
			
			<a href="/ruby/return-break-next" class="item">ruby中的return</a>
			
			<a href="/ruby/ruby-module-position" class="item">如何动态改变某个class的祖先链</a>
			
			<a href="/ruby/object-space" class="item">ObjectSpace介绍</a>
			
			<a href="/ruby/activesupport-notifications-3" class="item">Rails日志实现探索（3）</a>
			
			<a href="/ruby/activesupport-notifications-2" class="item">Rails日志实现探索（2）</a>
			
			<a href="/ruby/activesupport-notifications" class="item">Rails日志实现探索（1）</a>
			
			<a href="/ruby/rails-request" class="item">Rails中的request</a>
			
			<a href="/ruby/rescue-exception" class="item">rescue exception in ruby</a>
			
			<a href="/ruby/ruby-observer-pattern" class="item">设计模式之观察者模式</a>
			
			<a href="/ruby/ruby-require" class="item">require 的故事</a>
			
			<a href="/ruby/ruby-code-and-decode" class="item">ruby中的编码</a>
			
			<a href="/ruby/research-ruby" class="item">研究ruby的一些小技巧</a>
			
			<a href="/ruby/rails-middleware" class="item">Rails中间件</a>
			
			<a href="/ruby/ruby-serialize" class="item">ruby对象的序列化</a>
			
			<a href="/ruby/activesupport-message-verifier" class="item">ActiveSupport宝藏之MessageVerifier</a>
			
			<a href="/ruby/how-to-write-rakefile" class="item">如何写rakefile</a>
			
			<a href="/ruby/ruby-env" class="item">Ruby on Rails 环境及准备</a>
			
			<a href="/ruby/rack-based-app-boot" class="item">基于Rack的项目初始化</a>
			
		</div>
	</div>
	
	<div class="item ui dropdown">
		<a class="title">
			<i class="alarm outline icon"></i>
			<span>git</span>
		</a>
		<div class="menu content">
			
			<a href="/git/remove-git-history" class="item">如何移除某次提交之前的版本历史</a>
			
			<a href="/git/git-sheet" class="item">Git 不常用的好用的命令</a>
			
			<a href="/git/git-skill-ignore" class="item">Git高级技巧之忽略文件</a>
			
		</div>
	</div>
	
	<div class="item ui dropdown">
		<a class="title">
			<i class="alarm outline icon"></i>
			<span>database</span>
		</a>
		<div class="menu content">
			
			<a href="/database/mysql-sheet" class="item">Mysql数据库编码</a>
			
			<a href="/database/migrate-from-mongodb-to-mysql" class="item">从mongodb向mysql迁移数据</a>
			
		</div>
	</div>
	
</div>
  </div>
  <div class="content">
    <div class="ui grid">
  <div class="sixteen wide column">

    <h1 class="ui top attached center aligned header">
      Socket/HTTP/tcp 区别与联系

      
    </h1>

    <div class="ui attached segment">
    <h2 id="section">网络概述</h2>

<p>我们能够在网络上传输数据，需要一系列硬件和软件相互配合来完成。</p>

<table>
  <tbody>
    <tr>
      <td>应用层</td>
      <td>Http</td>
      <td>无需关心网络通信的具体细节</td>
    </tr>
    <tr>
      <td>传输层</td>
      <td>Tcp</td>
      <td>负责网络通信中的</td>
    </tr>
    <tr>
      <td>网络层</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性。</p>

<p>　　socket则是对TCP/IP协议的封装和应用(程序员层面上)。</p>

<p>　　也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，</p>

<p>　　而HTTP是应用层协议，主要解决如何包装数据。</p>

<p>　　关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：</p>

<p>　　“我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。</p>

<p>　　如果想要使传输的数据有意义，则必须使用到应用层协议。</p>

<p>　　应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。</p>

<p>　　WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”</p>

<p>　　而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。</p>

<p>　　通过Socket，我们才能使用TCP/IP协议。</p>

<p>　　实际上，Socket跟TCP/IP协议没有必然的联系。</p>

<p>　　Socket编程接口在设计的时候，就希望也能适应其他的网络协议。</p>

<p>　　所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，</p>

<p>　　从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。</p>

<p>　　网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：</p>

<p>　　“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。</p>

<p>　　这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，</p>

<p>　　TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。”</p>

<p>　　关于TCP/IP协议的相关只是，用博大精深来讲我想也不为过，单单查一下网上关于此类只是的资料和书籍文献的数量就知道，</p>

<p>　　这个我打算会买一些经典的书籍(比如《TCP/IP详解：卷一、卷二、卷三》)进行学习，今天就先总结一些基于基于TCP/IP协议的应用和编程接口的知识，也就是刚才说了很多的HTTP和Socket。</p>

<p>　　CSDN上有个比较形象的描述：HTTP是轿车，提供了封装或者显示数据的具体形式;Socket是发动机，提供了网络通信的能力。</p>

<p>　　实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。</p>

<p>　　下面是一些经常在笔试或者面试中碰到的重要的概念，特在此做摘抄和总结。</p>

<p>　　一、什么是TCP连接的三次握手</p>

<p>　　第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认;</p>

<p>　　第二次握手：服务器收到syn包，必须确认客户的SYN(ack=j+1)，同时自己也发送一个SYN包(syn=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态;</p>

<p>　　第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>

<p>　　握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>

<p>　　理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>

<p>　　断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”(过程就不细写了，就是服务器和客户端交互，最终确定断开)</p>

<p>　　二、利用Socket建立网络连接的步骤</p>

<p>　　建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。</p>

<p>　　套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>

<p>　　1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>

<p>　　2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。</p>

<p>　　为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>

<p>　　3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。</p>

<p>　　而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>

<p>　　三、HTTP链接的特点</p>

<p>　　HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p>

<p>　　HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p>

<p>　　四、TCP和UDP的区别(考得最多。。快被考烂了我觉得- -\)</p>

<p>　　1、TCP是面向链接的，虽然说网络的不安全不稳定特性决定了多少次握手都不能保证连接的可靠性，但TCP的三次握手在最低限度上(实际上也很大程度上保证了)保证了连接的可靠性;</p>

<p>　　而UDP不是面向连接的，UDP传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，当然也不用重发，所以说UDP是无连接的、不可靠的一种数据传输协议。</p>

<p>　　2、也正由于1所说的特点，使得UDP的开销更小数据传输速率更高，因为不必进行收发数据的确认，所以UDP的实时性更好。</p>

<p>　　知道了TCP和UDP的区别，就不难理解为何采用TCP传输协议的MSN比采用UDP的QQ传输文件慢了，但并不能说QQ的通信是不安全的，</p>

<p>　　因为程序员可以手动对UDP的数据收发进行验证，比如发送方对每个数据包进行编号然后由接收方进行验证啊什么的，</p>

<p>　　即使是这样，UDP因为在底层协议的封装上没有采用类似TCP的“三次握手”而实现了TCP所无法达到的传输效率。</p>

    </div>

  </div>
</div>
  </div>
</div>
</main>

<footer>
  <div class="ui divider"></div>
  <div class="ui center aligned segment basic">
    <p class="text-center text-muted">&copy; 2017 www.xinshengyin.com All rights reserved.  </p>
    <p class="text-center text-muted">版权所有</p>
  </div>
</footer>


  <script src="/assets/js/footer.js"></script>
  <script type="text/javascript" src="http://tajs.qq.com/stats?sId=39431539" charset="UTF-8"></script>
</body>

</html>
